# -*- coding: utf-8 -*-
"""mo-rac.py

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18iLnrdhWVNlwmY2p1d4Cd3CY71nO9OCc

**1. NJUTN-RAPSON**
"""

import math 
import numpy as np

def newtonRaphson(x0, tol):
  x_novo = x0         # pocetna tacka
  x_pre = math.inf    # iz paketa math vrednost beskonacnosti
  iter = 0

  while(abs(x_pre-x_novo)>tol):
    iter+=1
    x_pre = x_novo
    x_novo = x_pre - dfunc(x_pre)/ddfunc(x_pre)

  xopt = x_novo
  fopt = func(xopt)
  return xopt, fopt, iter

### PRIMER ###

def func(x):
  f = x**4 - 5*x**3 - 2*x**2 + 24*x
  return f

def dfunc(x):
  f = 4*x**3 - 15*x**2 - 4*x + 24
  return f

def ddfunc(x):
  f = 12*x**2 - 30*x - 4
  return f

### PRIMER POZIVA ###

tol = 0.0001
init_guess = 1
resenje = newtonRaphson(init_guess, tol)
print(resenje)

"""**2.** **SECICA** """

def secica(x1, x0, tol):
  x_pre = x0
  x_ppre = math.inf
  x_novo = x1
  iter = 0

  while(abs(x_novo-x_pre)>tol):
    iter+=1
    x_ppre = x_pre
    x_pre = x_novo
    x_novo = x_pre - dfunc(x_pre)*(x_pre-x_ppre)/(dfunc(x_pre)-dfunc(x_ppre))

  xopt = x_novo
  fopt = func(xopt)
  return xopt, fopt, iter

### PRIMER ###

def func(x):
  f = x**4 - 5*x**3 - 2*x**2 + 24*x
  return f

def dfunc(x):
  f = 4*x**3 - 15*x**2 - 4*x + 24
  return f

### PRIMER POZIVA ###

tol = 0.0001
init_guess1 = 0
init_guess2 = 3

resenje = secica(init_guess1, init_guess2, tol)
print(resenje)

"""**3. FIBONACI**"""

def fibonaci(a, b, tol):
  # 1. trazimo broj iteracija
  n = 1
  while (abs(b-a)/tol)>fibonaci_broj(n):
    n+=1

  # 2. odredjujemo pocetne tacke
  x1 = a + fibonaci_broj(n-2)/fibonaci_broj(n)*(b-a)
  x2 = a + b - x1

  # 3. iteracije (bice ih n-1)
  for i in range(2, n+1):
    if func(x1)<=func(x2):
      b = x2
      x2 = x1
      x1 = a+b-x2
    else:
      a = x1
      x1 = x2
      x2 = a+b-x1

  if func(x1)<func(x2):
    xopt = x1
    fopt = func(x1)
  else:
    xopt = x2
    fopt = func(x2)

  return xopt, fopt, n

def fibonaci_broj(n):
    #1 1 2 3 5 8
    if n < 3:
        f = 1
    else:
        fp = 1
        fpp = 1
        for i in range(3, n+1):
            f = fp + fpp
            fpp = fp
            fp = f
    return f

### POZIV ###

def func(x):
  f = -1*(x**4 - 5*x**3 - 2*x**2 + 24*x)
  return f

a = 0
b = 3
tol = 0.0001

resenje = fibonaci(a, b, tol)
print(resenje)

"""**4. ZLATNI PRESEK**"""

def zlatni_presek(a, b, tol):
  # 1. odredjujemo pocetne tacke i konstantu c (fibonacijev broj)
  c = (3-math.sqrt(5))/2
  x1 = a + c*(b-a)
  x2 = a + b - x1
  n = 1

  # 2. iterativno smanjujemo interval dok ne zadovoljimo zadatu preciznost
  while (b-a)>tol:
    n+=1
    if func(x1)<=func(x2):
      b = x2
      x1 = a + c*(b-a)
      x2 = a + b - x1
    else:
      a = x1
      x1 = a + c*(b-a)
      x2 = a + b - x1
  
  if func(x1)<=func(x2):
    xopt = x1
    fopt = func(x1)
  else:
    xopt = x2
    fopt = func(x2)

  return xopt, fopt, n

### POZIV ###

def func(x):
  f = -1*(x**4 - 5*x**3 - 2*x**2 + 24*x)
  return f

a = 0
b = 3
tol = 0.0001

resenje = zlatni_presek(a, b, tol)
print(resenje)

"""
**5. POLINOM**"""

import numpy.linalg as lin

def parabola(x1, x3, tol):
    X = np.array([x1, (x1+x3)/2, x3]).transpose()
    pom = np.array([1, 1, 1]).transpose()
    Y = np.array([pom, X, X*X]).transpose()
    F = np.linspace(0, 0, len(X))
    for i in range(0, len(X), 1):
        F[i] = func(X[i])
    abc = lin.solve(Y, F)

    x = -abc[1]/2/abc[2]
    fx = func(x)
    n = 0

    while np.abs(np.dot([1, x, x**2], abc) - fx) > tol:
        if (x > X[1]) and (x < X[2]):
            if (fx < F[1]) and (fx < F[2]):
                X = np.array([X[1], x, X[2]])
                F = np.array([F[1], fx, F[2]])
            elif (fx > F[1]) and (fx < F[2]):
                X = np.array([X[0], X[1], x])
                F = np.array([F[0], F[1], fx])
            else:
                print('Greska')
        elif (x > X[0]) and (x < X(2)):
            if (fx < F[0]) and (fx < F[1]):
                X = np.array([X[0], x, X[2]])
                F = np.array([F[0], fx, F[2]])
            elif (fx > F[1]) and (fx < F[0]):
                X = np.array([x, X[1], X[2]])
                F = np.array([fx, F[1], F[2]])
            else:
                print('Greska')
        else:
                print('x lezi van granica')

        pom = np.array([1, 1, 1]).transpose()
        Y = np.array([pom, X, X* X]).transpose()
        F = np.linspace(0, 0, len(X))
        for i in range(0, len(X), 1):
            F[i] = func(X[i])
        abc = lin.solve(Y, F)
        x = -abc[1]/2/abc[2]
        fx = func(x)
        n = n + 1
    return x, fx, n

def func(x):
    f = -1.*(x**4-5*x**3-2*x**2+24*x)
    return f

tol = 0.0001
init_guess = 1
[xopt, fopt, n] = parabola(0, 2, 0.0001)
print(xopt, fopt, n)

"""**GRADIJENTNE METODE**

6.   Najbrzi pad
7.   Najbrzi pad sa momentom
8.   Nesterov
9.   Adagrad
10.  Adam



"""

#gradf - funkcija koja racuna gradijent, x0 -pocetno pogadjanje, gamma - velicina koraka,
# epsilon - tolerancija, N - maksimalan broj koraka
def najbrzi_pad(gradf, x0, gamma, epsilon, N):
    x = np.array(x0).reshape(len(x0), 1) #prilagodjavanje oblika vektora/niza kako bi kod radio
    for k in range(N):
        g = gradf(x)
        x = x - gamma*g #Xk+1 = Xk - gamma*gradijent
        if np.linalg.norm(g) < epsilon: #duzina vektora manja od epsilon
            break
    return x, k+1

#omega - valjda momenat
def najbrzi_pad_moment(gradf, x0, gamma, epsilon, omega, N):
    x = np.array(x0).reshape(len(x0), 1)
    v = np.zeros(shape=x.shape)
    for k in range(N):
        g = gradf(x)
        v = omega*v + gamma*g #Vk = omega*Vk-1 + gamma*gradijent
        x = x - v # Xk+1 = Xk - Vk
        if np.linalg.norm(g) < epsilon:
            break
    return x, k+1

def adam(gradf, x0, gamma, omega1, omega2, epsilon1, epsilon, N):
    x = np.array(x0).reshape(len(x0),1)
    v = np.ones(shape=x.shape)
    m = np.ones(shape=x.shape)
    for k in range(N):
        g = gradf(x)
        m = omega1*m + (1 - omega1)*g
        v = omega2*v + (1 - omega2)*np.multiply(g, g)
        m_kor = m/(1-omega1)
        v_kor = abs( v/(1-omega2))
        x = x - gamma * m_kor / np.sqrt(v_kor + epsilon1)
        #print(x)
        if(np.linalg.norm(g)<epsilon):
            break
    
    return x, k+1

def nesterov(gradf, x0, gamma, epsilon, omega, N):
    x = [np.array(x0).reshape(len(x0), 1)]
    v = np.zeros(shape=x[-1].shape)
    for k in range(N):
        xpre = x[-1] - omega*v   # x_k prim
        g = gradf(xpre)
        v = omega*v + gamma*g
        x.append(x[-1] - v)
        if np.linalg.norm(g) < epsilon:
            break
    return x

def adagrad(gradf, x0, gamma, epsilon1, epsilon, N):
    x = [np.array(x0).reshape(len(x0), 1)]
    v = np.zeros(shape=x[-1].shape)
    G = [np.zeros(shape=x[-1].shape)]
    for k in range(N):
        g = np.asarray(gradf(x[-1]))
        G.append(G[-1] + np.multiply(g, g))
        v = gamma * np.ones(shape=G[-1].shape)/np.sqrt(G[-1] + epsilon1) * g
        x.append(x[-1] - v)
        if np.linalg.norm(g) < epsilon:
            break
    return x, G

# f = 1.5*x1^2 + x2^2 - 2*x1*x2 + 2*x1^3 + 0.5*x1^4
def func(x):
    return 1.5*x[0]**2 + x[1]**2 - 2*x[0]*x[1] + 2*x[0]**3 + 0.5*x[0]**4

# po x1 : 2*x1^3 + 6*x1^2 + 3*x1 - 2*x2
# po x2 : 2*x1 - 2*x2
def grad(x):
   x = np.array(x).reshape(np.size(x))
   return np.asarray([[2*x[0]**3 + 6*x[0]**2 + 3*x[0] - 2*x[1] ], [2*x[1] - 2*x[0]]])

#r, it = najbrzi_pad(lambda x: grad(x), [2,2], 0.1, 1e-4, 100)
r, it = najbrzi_pad_moment(lambda x: grad(x), [2,2], 0.05, 1e-4, 0.5, 100)
#r, it = adam(lambda x: grad(x), [2,2], 1e-4, 0.9, 0.999, 1e-6, 1e-6,  100)
#resenje = nesterov(lambda x: grad(x), x0=[2, 2], gamma=0.05, epsilon=1e-4, omega=0.5, N=100)
#resenje = adagrad(grad(x), x0=[2, 2], gamma=1, epsilon1=1e-6, epsilon=1e-6, N=100)
print('x opt:', r.round(2))
print('broj iteracija:', it)
print('vrednost f-je u optimumu: ', func(r))
# print(resenje)